{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-66ad3b74c19317c117cf45eef93741835e7e0352",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/milestone.sol": "project/contracts/milestone.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 1
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/milestone.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Interface for SovereignSeasV4\n */\ninterface ISovereignSeasV4 {\n    function nextProjectId() external view returns (uint256);\n    function nextCampaignId() external view returns (uint256);\n    function getProject(uint256 _projectId) external view returns (\n        uint256 id,\n        address owner,\n        string memory name,\n        string memory description,\n        bool transferrable,\n        bool active,\n        uint256 createdAt,\n        uint256[] memory campaignIds\n    );\n    function getCampaign(uint256 _campaignId) external view returns (\n        uint256 id,\n        address admin,\n        string memory name,\n        string memory description,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 adminFeePercentage,\n        uint256 maxWinners,\n        bool useQuadraticDistribution,\n        bool useCustomDistribution,\n        address payoutToken,\n        bool active,\n        uint256 totalFunds\n    );\n    function supportedTokens(address _token) external view returns (bool);\n    function superAdmins(address _admin) external view returns (bool);\n    function isCampaignAdmin(uint256 _campaignId, address _admin) external view returns (bool);\n    function celoToken() external view returns (IERC20);\n    function owner() external view returns (address);\n}\n\n/**\n * @title MilestoneBasedFunding\n * @dev Contract for milestone-based grant funding that interacts with deployed SovereignSeasV4\n * Supports escrow, time-locked approvals, and multi-token grants\n */\ncontract MilestoneBasedFunding is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Interface to deployed seas4 contract\n    ISovereignSeasV4 public seas4Contract;\n    IERC20 public celoToken;\n    \n    // Fee tracking (separate from seas4)\n    mapping(address => uint256) public collectedFees;\n\n    // Enums\n    enum EntityType { PROJECT, CAMPAIGN }\n    enum GrantStatus { ACTIVE, COMPLETED, CANCELLED }\n    enum MilestoneStatus { PENDING, SUBMITTED, APPROVED, REJECTED, PAID, LOCKED }\n    enum ProjectMilestoneType { INTERNAL, ASSIGNED, OPEN }\n    enum ProjectMilestoneStatus { DRAFT, ACTIVE, CLAIMED, SUBMITTED, APPROVED, REJECTED, PAID, CANCELLED }\n\n    // State Variables\n    uint256 public nextGrantId;\n    uint256 public nextMilestoneId;\n    uint256 public nextProjectMilestoneId;\n    uint256 public constant MIN_SITE_FEE = 1;\n    uint256 public constant MAX_SITE_FEE = 5;\n    uint256 public projectMilestonePlatformFee = 2; // 2% platform fee for project milestones (0-100)\n\n    // Mappings\n    mapping(uint256 => Grant) public grants;\n    mapping(uint256 => Milestone) public milestones;\n    mapping(uint256 => uint256[]) public grantMilestones; // grantId => milestoneIds[]\n    mapping(uint256 => mapping(uint256 => bool)) public grantHasMilestone; // grantId => milestoneId => exists\n    mapping(uint256 => address[]) public grantAdmins; // grantId => admins[]\n    mapping(uint256 => mapping(address => bool)) public isGrantAdmin; // grantId => admin => isAdmin\n    \n    // Project Milestone Mappings\n    mapping(uint256 => ProjectMilestone) public projectMilestones;\n    mapping(uint256 => uint256[]) public projectMilestoneIds; // projectId => milestoneIds[]\n    mapping(uint256 => mapping(uint256 => bool)) public projectHasMilestone; // projectId => milestoneId => exists\n    mapping(uint256 => address[]) public milestoneStewards; // milestoneId => stewards[]\n    mapping(uint256 => mapping(address => bool)) public isMilestoneSteward; // milestoneId => steward => isSteward\n    mapping(address => uint256[]) public userClaimedMilestones; // user => milestoneIds[]\n    mapping(address => mapping(uint256 => bool)) public hasUserClaimedMilestone; // user => milestoneId => hasClaimed\n\n    // Structs\n    struct Grant {\n        uint256 id;\n        address grantee;\n        uint256 linkedEntityId;\n        EntityType entityType;\n        address[] supportedTokens;\n        mapping(address => uint256) totalAmounts;\n        mapping(address => uint256) releasedAmounts;\n        mapping(address => uint256) escrowedAmounts;\n        uint256 siteFeePercentage; // 1-5%\n        uint256 reviewTimeLock; // in seconds\n        uint256 milestoneDeadline; // Deadline for milestone submissions (0 = no deadline)\n        GrantStatus status;\n        uint256 createdAt;\n        uint256 completedAt;\n    }\n\n    struct Milestone {\n        uint256 id;\n        uint256 grantId;\n        string title;\n        string description;\n        string evidenceHash; // IPFS hash\n        uint256 percentage; // Percentage of grant (same for all tokens)\n        mapping(address => uint256) payoutAmounts; // Calculated payout per token\n        MilestoneStatus status;\n        uint256 submittedAt;\n        uint256 reviewDeadline;\n        uint256 approvedAt;\n        address approvedBy;\n        string approvalMessage;\n        string rejectionMessage;\n        address rejectedBy;\n        uint256 rejectedAt;\n        bool autoApproved;\n        uint256 paidAt;\n        uint256 deadline; // Deadline for this milestone submission\n        uint256 penaltyPercentage; // Penalty applied (0-100)\n        bool isLocked; // True if milestone is locked out\n    }\n\n    struct ProjectMilestone {\n        uint256 id;\n        uint256 projectId;\n        ProjectMilestoneType milestoneType;\n        ProjectMilestoneStatus status;\n        \n        // Assignment\n        address assignedTo;              // For ASSIGNED type\n        address claimedBy;               // For OPEN type (who claimed it)\n        \n        // Content\n        string title;\n        string description;\n        string requirements;             // What needs to be done\n        string evidenceHash;             // IPFS hash of submitted evidence\n        \n        // Funding\n        address[] supportedTokens;\n        mapping(address => uint256) rewardAmounts;  // Reward per token\n        mapping(address => uint256) escrowedAmounts;\n        \n        // Approval\n        address[] approvers;             // Project owner + stewards\n        mapping(address => bool) isApprover;\n        mapping(address => bool) hasApproved;\n        uint256 requiredApprovals;       // How many approvals needed (default: 1)\n        bool allowSiteAdminApproval;     // Can site admin approve?\n        \n        // Timestamps\n        uint256 createdAt;\n        uint256 deadline;                // 0 = no deadline\n        uint256 claimedAt;\n        uint256 submittedAt;\n        uint256 approvedAt;\n        uint256 paidAt;\n        \n        // Metadata\n        string approvalMessage;\n        string rejectionMessage;\n        address approvedBy;\n        address rejectedBy;\n        uint256 rejectedAt;\n    }\n\n    // Events\n    event GrantCreated(\n        uint256 indexed grantId,\n        uint256 indexed linkedEntityId,\n        EntityType entityType,\n        address indexed grantee,\n        address[] tokens,\n        uint256[] amounts,\n        uint256 siteFeePercentage,\n        uint256 reviewTimeLock\n    );\n\n    event MilestoneSubmitted(\n        uint256 indexed grantId,\n        uint256 indexed milestoneId,\n        address indexed grantee,\n        string title,\n        string evidenceHash,\n        uint256 percentage\n    );\n\n    event MilestoneApproved(\n        uint256 indexed grantId,\n        uint256 indexed milestoneId,\n        address indexed approver,\n        string message,\n        bool autoApproved\n    );\n\n    event MilestoneRejected(\n        uint256 indexed grantId,\n        uint256 indexed milestoneId,\n        address indexed rejector,\n        string message\n    );\n\n    event MilestoneFundsReleased(\n        uint256 indexed grantId,\n        uint256 indexed milestoneId,\n        address indexed grantee,\n        address token,\n        uint256 amount,\n        uint256 siteFee\n    );\n\n    event FundsAddedToGrant(\n        uint256 indexed grantId,\n        address indexed token,\n        uint256 amount,\n        address addedBy\n    );\n\n    event FundsWithdrawnFromGrant(\n        uint256 indexed grantId,\n        address indexed token,\n        uint256 amount,\n        address recipient,\n        address withdrawnBy\n    );\n\n    event MilestonePenaltyApplied(\n        uint256 indexed grantId,\n        uint256 indexed milestoneId,\n        uint256 penaltyPercentage,\n        string reason\n    );\n\n    event MilestoneLocked(\n        uint256 indexed grantId,\n        uint256 indexed milestoneId,\n        string reason\n    );\n\n    event GrantCancelled(\n        uint256 indexed grantId,\n        address indexed cancelledBy,\n        address[] tokens,\n        uint256[] refundedAmounts\n    );\n\n    event GrantCompleted(\n        uint256 indexed grantId,\n        address indexed grantee,\n        uint256 completedAt\n    );\n\n    event GrantAdminAdded(\n        uint256 indexed grantId,\n        address indexed admin,\n        address indexed addedBy\n    );\n\n    event GrantAdminRemoved(\n        uint256 indexed grantId,\n        address indexed admin,\n        address indexed removedBy\n    );\n\n    event MilestoneResubmitted(\n        uint256 indexed grantId,\n        uint256 indexed milestoneId,\n        string newEvidenceHash\n    );\n\n    event FeeCollected(\n        address indexed token,\n        uint256 amount,\n        string feeType\n    );\n\n    // Project Milestone Events\n    event ProjectMilestoneCreated(\n        uint256 indexed projectId,\n        uint256 indexed milestoneId,\n        ProjectMilestoneType milestoneType,\n        address indexed assignedTo,\n        string title\n    );\n\n    event ProjectMilestoneFunded(\n        uint256 indexed milestoneId,\n        address indexed token,\n        uint256 amount,\n        address indexed funder\n    );\n\n    event OpenMilestoneClaimed(\n        uint256 indexed milestoneId,\n        address indexed claimedBy\n    );\n\n    event ProjectMilestoneEvidenceSubmitted(\n        uint256 indexed milestoneId,\n        address indexed submitter,\n        string evidenceHash\n    );\n\n    event ProjectMilestoneApproved(\n        uint256 indexed milestoneId,\n        address indexed approver,\n        string message\n    );\n\n    event ProjectMilestoneRejected(\n        uint256 indexed milestoneId,\n        address indexed rejector,\n        string message\n    );\n\n    event ProjectMilestoneRewardsClaimed(\n        uint256 indexed milestoneId,\n        address indexed recipient,\n        address indexed token,\n        uint256 amount\n    );\n\n    event ProjectMilestoneCancelled(\n        uint256 indexed milestoneId,\n        address indexed cancelledBy\n    );\n\n    event MilestoneStewardAdded(\n        uint256 indexed milestoneId,\n        address indexed steward,\n        address indexed addedBy\n    );\n\n    event MilestoneStewardRemoved(\n        uint256 indexed milestoneId,\n        address indexed steward,\n        address indexed removedBy\n    );\n\n    // Modifiers\n    modifier onlyGrantAdmin(uint256 _grantId) {\n        require(\n            isGrantAdmin[_grantId][msg.sender] || \n            seas4Contract.superAdmins(msg.sender) ||\n            _isCampaignAdminForGrant(_grantId),\n            \"Only grant admin can call this function\"\n        );\n        _;\n    }\n\n    modifier onlyGrantee(uint256 _grantId) {\n        require(grants[_grantId].grantee == msg.sender, \"Only grantee can call this function\");\n        _;\n    }\n\n    modifier validGrant(uint256 _grantId) {\n        require(_grantId < nextGrantId, \"Grant does not exist\");\n        require(grants[_grantId].status == GrantStatus.ACTIVE, \"Grant is not active\");\n        _;\n    }\n\n    modifier validMilestone(uint256 _milestoneId) {\n        require(_milestoneId < nextMilestoneId, \"Milestone does not exist\");\n        _;\n    }\n\n    modifier validSiteFee(uint256 _fee) {\n        require(_fee >= MIN_SITE_FEE && _fee <= MAX_SITE_FEE, \"Site fee must be between 1-5%\");\n        _;\n    }\n\n    modifier onlyProjectOwner(uint256 _projectId) {\n        (, address projectOwner,,,,,,) = seas4Contract.getProject(_projectId);\n        require(projectOwner == msg.sender, \"Only project owner can call this function\");\n        _;\n    }\n\n    modifier validProjectMilestone(uint256 _milestoneId) {\n        require(_milestoneId < nextProjectMilestoneId, \"Project milestone does not exist\");\n        _;\n    }\n\n    modifier onlyProjectMilestoneApprover(uint256 _milestoneId) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        require(\n            pm.isApprover[msg.sender] || \n            (pm.allowSiteAdminApproval && seas4Contract.superAdmins(msg.sender)),\n            \"Not authorized to approve this milestone\"\n        );\n        _;\n    }\n\n    constructor(address _seas4Contract) Ownable(msg.sender) validAddress(_seas4Contract) {\n        seas4Contract = ISovereignSeasV4(_seas4Contract);\n        celoToken = seas4Contract.celoToken();\n    }\n    \n    /**\n     * @dev Update the seas4 contract address (only owner)\n     */\n    function updateSeas4Contract(address _seas4Contract) external onlyOwner validAddress(_seas4Contract) {\n        seas4Contract = ISovereignSeasV4(_seas4Contract);\n        celoToken = seas4Contract.celoToken();\n    }\n    \n    modifier validAddress(address _addr) {\n        require(_addr != address(0), \"Invalid address\");\n        _;\n    }\n\n    /**\n     * @dev Check if caller is campaign admin for campaign-linked grants\n     */\n    function _isCampaignAdminForGrant(uint256 _grantId) internal view returns (bool) {\n        Grant storage grant = grants[_grantId];\n        if (grant.entityType == EntityType.CAMPAIGN) {\n            return seas4Contract.isCampaignAdmin(grant.linkedEntityId, msg.sender);\n        }\n        return false;\n    }\n\n    /**\n     * @dev Create a new grant with escrowed funds\n     * @param _linkedEntityId Project ID or Campaign ID\n     * @param _entityType PROJECT or CAMPAIGN\n     * @param _grantee Address receiving the grant\n     * @param _tokens Array of token addresses\n     * @param _amounts Array of amounts per token (must match _tokens length)\n     * @param _siteFeePercentage Site fee percentage (1-5)\n     * @param _reviewTimeLock Time lock in seconds for auto-approval\n     * @param _milestoneDeadline Deadline for milestone submissions (0 = no deadline)\n     */\n    function createGrant(\n        uint256 _linkedEntityId,\n        EntityType _entityType,\n        address _grantee,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _siteFeePercentage,\n        uint256 _reviewTimeLock,\n        uint256 _milestoneDeadline\n    ) external payable validAddress(_grantee) validSiteFee(_siteFeePercentage) nonReentrant {\n        require(_tokens.length == _amounts.length && _tokens.length > 0, \"Invalid tokens/amounts\");\n        require(_reviewTimeLock > 0, \"Review time lock must be greater than 0\");\n\n        // Validate entity exists\n        if (_entityType == EntityType.PROJECT) {\n            require(_linkedEntityId < seas4Contract.nextProjectId(), \"Project does not exist\");\n            (,,,,, bool active,,) = seas4Contract.getProject(_linkedEntityId);\n            require(active, \"Project is not active\");\n        } else {\n            require(_linkedEntityId < seas4Contract.nextCampaignId(), \"Campaign does not exist\");\n            (,,,,,,,,,,, bool active,) = seas4Contract.getCampaign(_linkedEntityId);\n            require(active, \"Campaign is not active\");\n            // Only campaign admins or super admins can create campaign-linked grants\n            require(\n                seas4Contract.isCampaignAdmin(_linkedEntityId, msg.sender) || seas4Contract.superAdmins(msg.sender),\n                \"Only campaign admin can create campaign-linked grant\"\n            );\n        }\n\n        uint256 grantId = nextGrantId++;\n        Grant storage newGrant = grants[grantId];\n        newGrant.id = grantId;\n        newGrant.grantee = _grantee;\n        newGrant.linkedEntityId = _linkedEntityId;\n        newGrant.entityType = _entityType;\n        newGrant.siteFeePercentage = _siteFeePercentage;\n        newGrant.reviewTimeLock = _reviewTimeLock;\n        newGrant.milestoneDeadline = _milestoneDeadline; // 0 means no deadline\n        newGrant.status = GrantStatus.ACTIVE;\n        newGrant.createdAt = block.timestamp;\n\n        // Calculate total CELO needed\n        uint256 totalCeloNeeded = 0;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_tokens[i] == address(celoToken)) {\n                totalCeloNeeded += _amounts[i];\n            }\n        }\n\n        // Validate CELO sent if needed\n        if (totalCeloNeeded > 0) {\n            require(msg.value >= totalCeloNeeded, \"Insufficient CELO sent\");\n        } else {\n            require(msg.value == 0, \"CELO sent but not needed\");\n        }\n\n        // Set up tokens and escrow funds\n        uint256 celoTransferred = 0;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            uint256 amount = _amounts[i];\n            \n            require(seas4Contract.supportedTokens(token), \"Token not supported\");\n            require(amount > 0, \"Amount must be greater than 0\");\n\n            newGrant.supportedTokens.push(token);\n            newGrant.totalAmounts[token] = amount;\n            newGrant.escrowedAmounts[token] = amount;\n\n            // Escrow funds\n            if (token == address(celoToken)) {\n                celoTransferred += amount;\n            } else {\n                IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n            }\n        }\n\n        // Refund excess CELO if any\n        if (msg.value > celoTransferred) {\n            payable(msg.sender).transfer(msg.value - celoTransferred);\n        }\n\n        // Set grant admins\n        if (_entityType == EntityType.CAMPAIGN) {\n            // Campaign admins become grant admins\n            (, address campaignAdmin,,,,,,,,,,,) = seas4Contract.getCampaign(_linkedEntityId);\n            grantAdmins[grantId].push(campaignAdmin);\n            isGrantAdmin[grantId][campaignAdmin] = true;\n            \n            // Add other campaign admins\n            // Note: We can't iterate campaign admins, so we'll add them as needed via addGrantAdmin\n        } else {\n            // For project grants, super admins are grant admins by default\n            // Can add specific admins later\n        }\n\n        emit GrantCreated(\n            grantId,\n            _linkedEntityId,\n            _entityType,\n            _grantee,\n            _tokens,\n            _amounts,\n            _siteFeePercentage,\n            _reviewTimeLock\n        );\n        // Note: milestoneDeadline is not in event to maintain backward compatibility\n    }\n\n    /**\n     * @dev Add a grant admin\n     */\n    function addGrantAdmin(uint256 _grantId, address _admin) external onlyGrantAdmin(_grantId) validAddress(_admin) {\n        require(!isGrantAdmin[_grantId][_admin], \"Already a grant admin\");\n        grantAdmins[_grantId].push(_admin);\n        isGrantAdmin[_grantId][_admin] = true;\n        emit GrantAdminAdded(_grantId, _admin, msg.sender);\n    }\n\n    /**\n     * @dev Remove a grant admin\n     */\n    function removeGrantAdmin(uint256 _grantId, address _admin) external onlyGrantAdmin(_grantId) {\n        require(isGrantAdmin[_grantId][_admin], \"Not a grant admin\");\n        require(_admin != msg.sender, \"Cannot remove yourself\");\n        isGrantAdmin[_grantId][_admin] = false;\n        emit GrantAdminRemoved(_grantId, _admin, msg.sender);\n    }\n\n    /**\n     * @dev Submit a milestone for approval\n     * @param _grantId Grant ID\n     * @param _title Milestone title\n     * @param _description Milestone description\n     * @param _evidenceHash IPFS hash of evidence\n     * @param _percentage Percentage of grant (must sum to <= 100% across all milestones)\n     */\n    function submitMilestone(\n        uint256 _grantId,\n        string memory _title,\n        string memory _description,\n        string memory _evidenceHash,\n        uint256 _percentage\n    ) external onlyGrantee(_grantId) validGrant(_grantId) {\n        require(_percentage > 0 && _percentage <= 100, \"Invalid percentage\");\n        require(bytes(_title).length > 0, \"Title required\");\n        require(bytes(_evidenceHash).length > 0, \"Evidence hash required\");\n\n        // Check total percentage doesn't exceed 100%\n        uint256 totalPercentage = _percentage;\n        uint256[] memory milestoneIds = grantMilestones[_grantId];\n        for (uint256 i = 0; i < milestoneIds.length; i++) {\n            Milestone storage ms = milestones[milestoneIds[i]];\n            if (ms.status == MilestoneStatus.PENDING || \n                ms.status == MilestoneStatus.SUBMITTED || \n                ms.status == MilestoneStatus.APPROVED ||\n                ms.status == MilestoneStatus.PAID) {\n                totalPercentage += ms.percentage;\n            }\n        }\n        require(totalPercentage <= 100, \"Total milestone percentage exceeds 100%\");\n\n        Grant storage grant = grants[_grantId];\n        \n        // Check if milestone should be locked (1 month past deadline)\n        uint256 currentDeadline = grant.milestoneDeadline > 0 ? grant.milestoneDeadline : type(uint256).max;\n        uint256 oneMonth = 30 days;\n        \n        if (grant.milestoneDeadline > 0 && block.timestamp > grant.milestoneDeadline + oneMonth) {\n            // Milestone is locked out - cannot submit\n            revert(\"Milestone submission deadline has passed and milestone is locked\");\n        }\n\n        uint256 milestoneId = nextMilestoneId++;\n        Milestone storage newMilestone = milestones[milestoneId];\n        newMilestone.id = milestoneId;\n        newMilestone.grantId = _grantId;\n        newMilestone.title = _title;\n        newMilestone.description = _description;\n        newMilestone.evidenceHash = _evidenceHash;\n        newMilestone.percentage = _percentage;\n        newMilestone.deadline = currentDeadline;\n        newMilestone.submittedAt = block.timestamp;\n        newMilestone.reviewDeadline = block.timestamp + grant.reviewTimeLock;\n        \n        // Check if submitted late and apply penalty\n        uint256 penaltyPercentage = 0;\n        if (grant.milestoneDeadline > 0 && block.timestamp > grant.milestoneDeadline) {\n            // Submitted after deadline but within 1 month - apply 5% penalty\n            if (block.timestamp <= grant.milestoneDeadline + oneMonth) {\n                penaltyPercentage = 5;\n                newMilestone.penaltyPercentage = penaltyPercentage;\n                emit MilestonePenaltyApplied(_grantId, milestoneId, penaltyPercentage, \"Submitted after deadline\");\n            }\n        }\n        \n        newMilestone.status = MilestoneStatus.SUBMITTED;\n\n        // Calculate payout amounts per token (with penalty deduction if applicable)\n        for (uint256 i = 0; i < grant.supportedTokens.length; i++) {\n            address token = grant.supportedTokens[i];\n            uint256 basePayout = (grant.totalAmounts[token] * _percentage) / 100;\n            // Apply penalty: reduce payout by penalty percentage\n            uint256 payout = penaltyPercentage > 0 \n                ? (basePayout * (100 - penaltyPercentage)) / 100 \n                : basePayout;\n            newMilestone.payoutAmounts[token] = payout;\n        }\n\n        grantMilestones[_grantId].push(milestoneId);\n        grantHasMilestone[_grantId][milestoneId] = true;\n\n        emit MilestoneSubmitted(\n            _grantId,\n            milestoneId,\n            grant.grantee,\n            _title,\n            _evidenceHash,\n            _percentage\n        );\n    }\n\n    /**\n     * @dev Approve a milestone and release funds\n     * @param _grantId Grant ID\n     * @param _milestoneId Milestone ID\n     * @param _message Approval message (required)\n     */\n    function approveMilestone(\n        uint256 _grantId,\n        uint256 _milestoneId,\n        string memory _message\n    ) external onlyGrantAdmin(_grantId) validGrant(_grantId) validMilestone(_milestoneId) nonReentrant {\n        require(bytes(_message).length > 0, \"Approval message required\");\n        require(grantHasMilestone[_grantId][_milestoneId], \"Milestone not part of grant\");\n\n        Milestone storage milestone = milestones[_milestoneId];\n        require(milestone.status == MilestoneStatus.SUBMITTED, \"Milestone not submitted\");\n        require(milestone.grantId == _grantId, \"Milestone grant mismatch\");\n\n        milestone.status = MilestoneStatus.APPROVED;\n        milestone.approvedAt = block.timestamp;\n        milestone.approvedBy = msg.sender;\n        milestone.approvalMessage = _message;\n        milestone.autoApproved = false;\n\n        _releaseMilestoneFunds(_grantId, _milestoneId);\n\n        emit MilestoneApproved(_grantId, _milestoneId, msg.sender, _message, false);\n    }\n\n    /**\n     * @dev Reject a milestone\n     * @param _grantId Grant ID\n     * @param _milestoneId Milestone ID\n     * @param _message Rejection message (required)\n     */\n    function rejectMilestone(\n        uint256 _grantId,\n        uint256 _milestoneId,\n        string memory _message\n    ) external onlyGrantAdmin(_grantId) validGrant(_grantId) validMilestone(_milestoneId) {\n        require(bytes(_message).length > 0, \"Rejection message required\");\n        require(grantHasMilestone[_grantId][_milestoneId], \"Milestone not part of grant\");\n\n        Milestone storage milestone = milestones[_milestoneId];\n        require(milestone.status == MilestoneStatus.SUBMITTED, \"Milestone not submitted\");\n        require(milestone.grantId == _grantId, \"Milestone grant mismatch\");\n\n        milestone.status = MilestoneStatus.REJECTED;\n        milestone.rejectedAt = block.timestamp;\n        milestone.rejectedBy = msg.sender;\n        milestone.rejectionMessage = _message;\n\n        emit MilestoneRejected(_grantId, _milestoneId, msg.sender, _message);\n    }\n\n    /**\n     * @dev Check and auto-approve milestone if review deadline passed\n     * @param _grantId Grant ID\n     * @param _milestoneId Milestone ID\n     */\n    function checkAndAutoApproveMilestone(\n        uint256 _grantId,\n        uint256 _milestoneId\n    ) external validGrant(_grantId) validMilestone(_milestoneId) nonReentrant {\n        require(grantHasMilestone[_grantId][_milestoneId], \"Milestone not part of grant\");\n\n        Milestone storage milestone = milestones[_milestoneId];\n        require(milestone.status == MilestoneStatus.SUBMITTED, \"Milestone not submitted\");\n        require(milestone.grantId == _grantId, \"Milestone grant mismatch\");\n        require(block.timestamp >= milestone.reviewDeadline, \"Review deadline not reached\");\n\n        milestone.status = MilestoneStatus.APPROVED;\n        milestone.approvedAt = block.timestamp;\n        milestone.approvedBy = address(0); // Auto-approved\n        milestone.approvalMessage = \"Auto-approved after review deadline\";\n        milestone.autoApproved = true;\n\n        _releaseMilestoneFunds(_grantId, _milestoneId);\n\n        emit MilestoneApproved(_grantId, _milestoneId, address(0), \"Auto-approved after review deadline\", true);\n    }\n\n    /**\n     * @dev Resubmit a rejected milestone\n     * @param _grantId Grant ID\n     * @param _milestoneId Milestone ID\n     * @param _newEvidenceHash New IPFS hash\n     */\n    function resubmitMilestone(\n        uint256 _grantId,\n        uint256 _milestoneId,\n        string memory _newEvidenceHash\n    ) external onlyGrantee(_grantId) validGrant(_grantId) validMilestone(_milestoneId) {\n        require(bytes(_newEvidenceHash).length > 0, \"Evidence hash required\");\n        require(grantHasMilestone[_grantId][_milestoneId], \"Milestone not part of grant\");\n\n        Milestone storage milestone = milestones[_milestoneId];\n        require(milestone.status == MilestoneStatus.REJECTED, \"Milestone not rejected\");\n        require(milestone.grantId == _grantId, \"Milestone grant mismatch\");\n\n        milestone.status = MilestoneStatus.SUBMITTED;\n        milestone.evidenceHash = _newEvidenceHash;\n        milestone.submittedAt = block.timestamp;\n        milestone.reviewDeadline = block.timestamp + grants[_grantId].reviewTimeLock;\n        // Clear rejection data\n        milestone.rejectedBy = address(0);\n        milestone.rejectedAt = 0;\n        milestone.rejectionMessage = \"\";\n\n        emit MilestoneResubmitted(_grantId, _milestoneId, _newEvidenceHash);\n        emit MilestoneSubmitted(\n            _grantId,\n            _milestoneId,\n            grants[_grantId].grantee,\n            milestone.title,\n            _newEvidenceHash,\n            milestone.percentage\n        );\n    }\n\n    /**\n     * @dev Internal function to release milestone funds\n     */\n    function _releaseMilestoneFunds(uint256 _grantId, uint256 _milestoneId) internal {\n        Milestone storage milestone = milestones[_milestoneId];\n        Grant storage grant = grants[_grantId];\n\n        require(milestone.status == MilestoneStatus.APPROVED, \"Milestone not approved\");\n\n        bool fundsReleased = false;\n        for (uint256 i = 0; i < grant.supportedTokens.length; i++) {\n            address token = grant.supportedTokens[i];\n            uint256 payout = milestone.payoutAmounts[token];\n            \n            if (payout > 0 && grant.escrowedAmounts[token] >= payout) {\n                fundsReleased = true;\n                \n                // Calculate site fee\n                uint256 siteFee = (payout * grant.siteFeePercentage) / 100;\n                uint256 granteeAmount = payout - siteFee;\n\n                // Update grant tracking\n                grant.escrowedAmounts[token] -= payout;\n                grant.releasedAmounts[token] += payout;\n\n                // Transfer to grantee\n                if (token == address(celoToken)) {\n                    payable(grant.grantee).transfer(granteeAmount);\n                } else {\n                    IERC20(token).safeTransfer(grant.grantee, granteeAmount);\n                }\n\n                // Collect site fee\n                if (siteFee > 0) {\n                    address platformOwner = seas4Contract.owner();\n                    if (token == address(celoToken)) {\n                        // Site fee goes to platform owner\n                        payable(platformOwner).transfer(siteFee);\n                    } else {\n                        IERC20(token).safeTransfer(platformOwner, siteFee);\n                    }\n                    collectedFees[token] += siteFee;\n                    emit FeeCollected(token, siteFee, \"milestoneSiteFee\");\n                }\n\n                emit MilestoneFundsReleased(\n                    _grantId,\n                    _milestoneId,\n                    grant.grantee,\n                    token,\n                    granteeAmount,\n                    siteFee\n                );\n            }\n        }\n\n        // Mark milestone as paid if funds were released\n        if (fundsReleased) {\n            milestone.status = MilestoneStatus.PAID;\n            milestone.paidAt = block.timestamp;\n        }\n\n        // Check if grant is completed\n        _checkGrantCompletion(_grantId);\n    }\n\n    /**\n     * @dev Add funds to an existing grant\n     * @param _grantId Grant ID\n     * @param _tokens Array of token addresses\n     * @param _amounts Array of amounts per token\n     */\n    function addFundsToGrant(\n        uint256 _grantId,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) external payable validGrant(_grantId) nonReentrant {\n        require(_tokens.length == _amounts.length && _tokens.length > 0, \"Invalid tokens/amounts\");\n        Grant storage grant = grants[_grantId];\n        require(grant.status == GrantStatus.ACTIVE, \"Grant must be active\");\n\n        // Calculate total CELO needed\n        uint256 totalCeloNeeded = 0;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_tokens[i] == address(celoToken)) {\n                totalCeloNeeded += _amounts[i];\n            }\n        }\n\n        // Validate CELO sent if needed\n        if (totalCeloNeeded > 0) {\n            require(msg.value >= totalCeloNeeded, \"Insufficient CELO sent\");\n        }\n\n        uint256 celoTransferred = 0;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            uint256 amount = _amounts[i];\n            \n            require(seas4Contract.supportedTokens(token), \"Token not supported\");\n            require(amount > 0, \"Amount must be greater than 0\");\n\n            // Check if token is already in grant, if not add it\n            bool tokenExists = false;\n            for (uint256 j = 0; j < grant.supportedTokens.length; j++) {\n                if (grant.supportedTokens[j] == token) {\n                    tokenExists = true;\n                    break;\n                }\n            }\n            \n            if (!tokenExists) {\n                grant.supportedTokens.push(token);\n            }\n\n            // Add to totals and escrow\n            grant.totalAmounts[token] += amount;\n            grant.escrowedAmounts[token] += amount;\n\n            // Escrow funds\n            if (token == address(celoToken)) {\n                celoTransferred += amount;\n            } else {\n                IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n            }\n\n            emit FundsAddedToGrant(_grantId, token, amount, msg.sender);\n        }\n\n        // Refund excess CELO\n        if (msg.value > celoTransferred) {\n            payable(msg.sender).transfer(msg.value - celoTransferred);\n        }\n    }\n\n    /**\n     * @dev Withdraw funds from a grant (only grant admin, before milestones are submitted)\n     * @param _grantId Grant ID\n     * @param _token Token address\n     * @param _amount Amount to withdraw\n     * @param _recipient Address to receive the funds\n     */\n    function withdrawFundsFromGrant(\n        uint256 _grantId,\n        address _token,\n        uint256 _amount,\n        address _recipient\n    ) external onlyGrantAdmin(_grantId) validGrant(_grantId) validAddress(_recipient) nonReentrant {\n        Grant storage grant = grants[_grantId];\n        require(grant.status == GrantStatus.ACTIVE, \"Grant must be active\");\n        \n        // Check that no milestones have been submitted yet\n        require(grantMilestones[_grantId].length == 0, \"Cannot withdraw funds after milestones are submitted\");\n        \n        require(grant.escrowedAmounts[_token] >= _amount, \"Insufficient escrowed funds\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        // Update escrowed amounts\n        grant.escrowedAmounts[_token] -= _amount;\n        grant.totalAmounts[_token] -= _amount;\n\n        // Transfer funds\n        if (_token == address(celoToken)) {\n            payable(_recipient).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_recipient, _amount);\n        }\n\n        emit FundsWithdrawnFromGrant(_grantId, _token, _amount, _recipient, msg.sender);\n    }\n\n    /**\n     * @dev Check if all milestones are paid and mark grant as completed\n     */\n    function _checkGrantCompletion(uint256 _grantId) internal {\n        Grant storage grant = grants[_grantId];\n        if (grant.status != GrantStatus.ACTIVE) return;\n\n        uint256[] memory milestoneIds = grantMilestones[_grantId];\n        bool allPaid = true;\n        uint256 totalPercentage = 0;\n\n        for (uint256 i = 0; i < milestoneIds.length; i++) {\n            Milestone storage ms = milestones[milestoneIds[i]];\n            if (ms.status == MilestoneStatus.PAID) {\n                totalPercentage += ms.percentage;\n            } else if (ms.status == MilestoneStatus.SUBMITTED || ms.status == MilestoneStatus.APPROVED) {\n                allPaid = false;\n                break;\n            }\n        }\n\n        // Grant is completed if all submitted milestones are paid AND total percentage is 100%\n        if (allPaid && milestoneIds.length > 0 && totalPercentage == 100) {\n            grant.status = GrantStatus.COMPLETED;\n            grant.completedAt = block.timestamp;\n            emit GrantCompleted(_grantId, grant.grantee, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Cancel a grant and refund escrowed funds\n     * @param _grantId Grant ID\n     * @param _refundTo Address to refund to (must be grant creator or super admin)\n     */\n    function cancelGrant(\n        uint256 _grantId,\n        address _refundTo\n    ) external onlyGrantAdmin(_grantId) validAddress(_refundTo) nonReentrant {\n        Grant storage grant = grants[_grantId];\n        require(grant.status == GrantStatus.ACTIVE, \"Grant not active\");\n\n        grant.status = GrantStatus.CANCELLED;\n\n        address[] memory tokens = grant.supportedTokens;\n        uint256[] memory refundedAmounts = new uint256[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address token = tokens[i];\n            uint256 refundAmount = grant.escrowedAmounts[token];\n            \n            if (refundAmount > 0) {\n                grant.escrowedAmounts[token] = 0;\n                refundedAmounts[i] = refundAmount;\n\n                if (token == address(celoToken)) {\n                    payable(_refundTo).transfer(refundAmount);\n                } else {\n                    IERC20(token).safeTransfer(_refundTo, refundAmount);\n                }\n            }\n        }\n\n        emit GrantCancelled(_grantId, msg.sender, tokens, refundedAmounts);\n    }\n\n    // View Functions\n\n    /**\n     * @dev Get grant details\n     */\n    function getGrant(uint256 _grantId) external view returns (\n        uint256 id,\n        address grantee,\n        uint256 linkedEntityId,\n        EntityType entityType,\n        uint256 siteFeePercentage,\n        uint256 reviewTimeLock,\n        uint256 milestoneDeadline,\n        GrantStatus status,\n        uint256 createdAt,\n        uint256 completedAt,\n        address[] memory supportedTokens\n    ) {\n        Grant storage grant = grants[_grantId];\n        return (\n            grant.id,\n            grant.grantee,\n            grant.linkedEntityId,\n            grant.entityType,\n            grant.siteFeePercentage,\n            grant.reviewTimeLock,\n            grant.milestoneDeadline,\n            grant.status,\n            grant.createdAt,\n            grant.completedAt,\n            grant.supportedTokens\n        );\n    }\n\n    /**\n     * @dev Get grant token amounts\n     */\n    function getGrantTokenAmounts(uint256 _grantId, address _token) external view returns (\n        uint256 totalAmount,\n        uint256 releasedAmount,\n        uint256 escrowedAmount\n    ) {\n        Grant storage grant = grants[_grantId];\n        return (\n            grant.totalAmounts[_token],\n            grant.releasedAmounts[_token],\n            grant.escrowedAmounts[_token]\n        );\n    }\n\n    /**\n     * @dev Get milestone details\n     */\n    function getMilestone(uint256 _milestoneId) external view returns (\n        uint256 id,\n        uint256 grantId,\n        string memory title,\n        string memory description,\n        string memory evidenceHash,\n        uint256 percentage,\n        MilestoneStatus status,\n        uint256 submittedAt,\n        uint256 reviewDeadline,\n        uint256 approvedAt,\n        address approvedBy,\n        string memory approvalMessage,\n        bool autoApproved,\n        uint256 paidAt,\n        uint256 deadline,\n        uint256 penaltyPercentage,\n        bool isLocked\n    ) {\n        Milestone storage milestone = milestones[_milestoneId];\n        return (\n            milestone.id,\n            milestone.grantId,\n            milestone.title,\n            milestone.description,\n            milestone.evidenceHash,\n            milestone.percentage,\n            milestone.status,\n            milestone.submittedAt,\n            milestone.reviewDeadline,\n            milestone.approvedAt,\n            milestone.approvedBy,\n            milestone.approvalMessage,\n            milestone.autoApproved,\n            milestone.paidAt,\n            milestone.deadline,\n            milestone.penaltyPercentage,\n            milestone.isLocked\n        );\n    }\n\n    /**\n     * @dev Get milestone payout amount for a token\n     */\n    function getMilestonePayout(uint256 _milestoneId, address _token) external view returns (uint256) {\n        return milestones[_milestoneId].payoutAmounts[_token];\n    }\n\n    /**\n     * @dev Get milestone rejection details\n     */\n    function getMilestoneRejection(uint256 _milestoneId) external view returns (\n        string memory rejectionMessage,\n        address rejectedBy,\n        uint256 rejectedAt\n    ) {\n        Milestone storage milestone = milestones[_milestoneId];\n        return (\n            milestone.rejectionMessage,\n            milestone.rejectedBy,\n            milestone.rejectedAt\n        );\n    }\n\n    /**\n     * @dev Get all milestone IDs for a grant\n     */\n    function getGrantMilestones(uint256 _grantId) external view returns (uint256[] memory) {\n        return grantMilestones[_grantId];\n    }\n\n    /**\n     * @dev Get grant admins\n     */\n    function getGrantAdmins(uint256 _grantId) external view returns (address[] memory) {\n        return grantAdmins[_grantId];\n    }\n\n    /**\n     * @dev Get grant count\n     */\n    function getGrantCount() external view returns (uint256) {\n        return nextGrantId;\n    }\n\n    /**\n     * @dev Get milestone count\n     */\n    function getMilestoneCount() external view returns (uint256) {\n        return nextMilestoneId;\n    }\n\n    /**\n     * @dev Check if milestone can be auto-approved\n     */\n    function canAutoApproveMilestone(uint256 _milestoneId) external view returns (bool) {\n        Milestone storage milestone = milestones[_milestoneId];\n        return (\n            milestone.status == MilestoneStatus.SUBMITTED &&\n            block.timestamp >= milestone.reviewDeadline\n        );\n    }\n\n    // ============ PROJECT MILESTONE FUNCTIONS ============\n\n    /**\n     * @dev Create a new project milestone\n     * @param _projectId Project ID (must exist in SovSeas)\n     * @param _milestoneType INTERNAL, ASSIGNED, or OPEN\n     * @param _assignedTo Address for ASSIGNED type (ignored for INTERNAL/OPEN)\n     * @param _title Milestone title\n     * @param _description Milestone description\n     * @param _requirements What needs to be done\n     * @param _deadline Deadline timestamp (0 = no deadline)\n     * @param _requiredApprovals Number of approvals needed (default: 1)\n     * @param _allowSiteAdminApproval Can site admin approve?\n     * @param _stewards Array of steward addresses (optional)\n     */\n    function createProjectMilestone(\n        uint256 _projectId,\n        ProjectMilestoneType _milestoneType,\n        address _assignedTo,\n        string memory _title,\n        string memory _description,\n        string memory _requirements,\n        uint256 _deadline,\n        uint256 _requiredApprovals,\n        bool _allowSiteAdminApproval,\n        address[] memory _stewards\n    ) external onlyProjectOwner(_projectId) {\n        require(_projectId < seas4Contract.nextProjectId(), \"Project does not exist\");\n        (,,,,, bool active,,) = seas4Contract.getProject(_projectId);\n        require(active, \"Project is not active\");\n        require(bytes(_title).length > 0, \"Title required\");\n        require(_requiredApprovals > 0, \"Required approvals must be > 0\");\n\n        uint256 milestoneId = nextProjectMilestoneId++;\n        ProjectMilestone storage pm = projectMilestones[milestoneId];\n        pm.id = milestoneId;\n        pm.projectId = _projectId;\n        pm.milestoneType = _milestoneType;\n        pm.status = ProjectMilestoneStatus.DRAFT;\n        pm.title = _title;\n        pm.description = _description;\n        pm.requirements = _requirements;\n        pm.deadline = _deadline;\n        pm.requiredApprovals = _requiredApprovals;\n        pm.allowSiteAdminApproval = _allowSiteAdminApproval;\n        pm.createdAt = block.timestamp;\n\n        // Set assignment based on type\n        (, address projectOwner,,,,,,) = seas4Contract.getProject(_projectId);\n        if (_milestoneType == ProjectMilestoneType.INTERNAL) {\n            pm.assignedTo = projectOwner;\n        } else if (_milestoneType == ProjectMilestoneType.ASSIGNED) {\n            require(_assignedTo != address(0), \"Assigned address required\");\n            pm.assignedTo = _assignedTo;\n        }\n        // OPEN type: assignedTo remains address(0) until claimed\n\n        // Add project owner as approver\n        pm.approvers.push(projectOwner);\n        pm.isApprover[projectOwner] = true;\n\n        // Add stewards as approvers\n        for (uint256 i = 0; i < _stewards.length; i++) {\n            if (_stewards[i] != address(0) && !pm.isApprover[_stewards[i]]) {\n                pm.approvers.push(_stewards[i]);\n                pm.isApprover[_stewards[i]] = true;\n                milestoneStewards[milestoneId].push(_stewards[i]);\n                isMilestoneSteward[milestoneId][_stewards[i]] = true;\n            }\n        }\n\n        projectMilestoneIds[_projectId].push(milestoneId);\n        projectHasMilestone[_projectId][milestoneId] = true;\n\n        emit ProjectMilestoneCreated(_projectId, milestoneId, _milestoneType, pm.assignedTo, _title);\n    }\n\n    /**\n     * @dev Fund a project milestone with tokens\n     * @param _milestoneId Milestone ID\n     * @param _tokens Array of token addresses\n     * @param _amounts Array of amounts per token\n     */\n    function fundProjectMilestone(\n        uint256 _milestoneId,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) external payable validProjectMilestone(_milestoneId) nonReentrant {\n        require(_tokens.length == _amounts.length && _tokens.length > 0, \"Invalid tokens/amounts\");\n        \n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        require(\n            pm.status == ProjectMilestoneStatus.DRAFT || pm.status == ProjectMilestoneStatus.ACTIVE,\n            \"Milestone not in fundable state\"\n        );\n\n        // Calculate total CELO needed\n        uint256 totalCeloNeeded = 0;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_tokens[i] == address(celoToken)) {\n                totalCeloNeeded += _amounts[i];\n            }\n        }\n\n        // Validate CELO sent if needed\n        if (totalCeloNeeded > 0) {\n            require(msg.value >= totalCeloNeeded, \"Insufficient CELO sent\");\n        }\n\n        uint256 celoTransferred = 0;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            uint256 amount = _amounts[i];\n            \n            require(seas4Contract.supportedTokens(token), \"Token not supported\");\n            require(amount > 0, \"Amount must be greater than 0\");\n\n            // Check if token already exists\n            bool tokenExists = false;\n            for (uint256 j = 0; j < pm.supportedTokens.length; j++) {\n                if (pm.supportedTokens[j] == token) {\n                    tokenExists = true;\n                    break;\n                }\n            }\n            \n            if (!tokenExists) {\n                pm.supportedTokens.push(token);\n            }\n\n            // Add to rewards and escrow\n            pm.rewardAmounts[token] += amount;\n            pm.escrowedAmounts[token] += amount;\n\n            // Escrow funds\n            if (token == address(celoToken)) {\n                celoTransferred += amount;\n            } else {\n                IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n            }\n\n            emit ProjectMilestoneFunded(_milestoneId, token, amount, msg.sender);\n        }\n\n        // Refund excess CELO\n        if (msg.value > celoTransferred) {\n            payable(msg.sender).transfer(msg.value - celoTransferred);\n        }\n\n        // Activate milestone if it was in DRAFT\n        if (pm.status == ProjectMilestoneStatus.DRAFT) {\n            pm.status = ProjectMilestoneStatus.ACTIVE;\n        }\n    }\n\n    /**\n     * @dev Claim an open milestone\n     * @param _milestoneId Milestone ID\n     */\n    function claimOpenMilestone(uint256 _milestoneId) external validProjectMilestone(_milestoneId) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        require(pm.milestoneType == ProjectMilestoneType.OPEN, \"Not an open milestone\");\n        require(pm.status == ProjectMilestoneStatus.ACTIVE, \"Milestone not active\");\n        require(pm.claimedBy == address(0), \"Milestone already claimed\");\n\n        pm.claimedBy = msg.sender;\n        pm.assignedTo = msg.sender;\n        pm.status = ProjectMilestoneStatus.CLAIMED;\n        pm.claimedAt = block.timestamp;\n\n        if (!hasUserClaimedMilestone[msg.sender][_milestoneId]) {\n            userClaimedMilestones[msg.sender].push(_milestoneId);\n            hasUserClaimedMilestone[msg.sender][_milestoneId] = true;\n        }\n\n        emit OpenMilestoneClaimed(_milestoneId, msg.sender);\n    }\n\n    /**\n     * @dev Submit evidence for milestone completion\n     * @param _milestoneId Milestone ID\n     * @param _evidenceHash IPFS hash of evidence\n     */\n    function submitMilestoneEvidence(\n        uint256 _milestoneId,\n        string memory _evidenceHash\n    ) external validProjectMilestone(_milestoneId) {\n        require(bytes(_evidenceHash).length > 0, \"Evidence hash required\");\n        \n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        \n        // Check if user is authorized to submit\n        if (pm.milestoneType == ProjectMilestoneType.OPEN) {\n            require(pm.claimedBy == msg.sender, \"Only claimer can submit\");\n            require(pm.status == ProjectMilestoneStatus.CLAIMED, \"Milestone not claimed\");\n        } else {\n            require(pm.assignedTo == msg.sender, \"Only assigned user can submit\");\n            require(\n                pm.status == ProjectMilestoneStatus.ACTIVE || pm.status == ProjectMilestoneStatus.REJECTED,\n                \"Invalid status for submission\"\n            );\n        }\n\n        pm.evidenceHash = _evidenceHash;\n        pm.status = ProjectMilestoneStatus.SUBMITTED;\n        pm.submittedAt = block.timestamp;\n\n        // Reset approvals\n        for (uint256 i = 0; i < pm.approvers.length; i++) {\n            pm.hasApproved[pm.approvers[i]] = false;\n        }\n\n        emit ProjectMilestoneEvidenceSubmitted(_milestoneId, msg.sender, _evidenceHash);\n    }\n\n    /**\n     * @dev Approve a project milestone\n     * @param _milestoneId Milestone ID\n     * @param _message Approval message\n     */\n    function approveProjectMilestone(\n        uint256 _milestoneId,\n        string memory _message\n    ) external onlyProjectMilestoneApprover(_milestoneId) validProjectMilestone(_milestoneId) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        require(pm.status == ProjectMilestoneStatus.SUBMITTED, \"Milestone not submitted\");\n        require(!pm.hasApproved[msg.sender], \"Already approved\");\n\n        // Mark as approved (only if not site admin, site admin approval is separate)\n        if (pm.isApprover[msg.sender]) {\n            pm.hasApproved[msg.sender] = true;\n        }\n\n        // Count approvals\n        uint256 approvalCount = 0;\n        for (uint256 i = 0; i < pm.approvers.length; i++) {\n            if (pm.hasApproved[pm.approvers[i]]) {\n                approvalCount++;\n            }\n        }\n\n        // Site admin approval counts as 1 if enabled\n        if (pm.allowSiteAdminApproval && seas4Contract.superAdmins(msg.sender)) {\n            approvalCount++;\n        }\n\n        if (approvalCount >= pm.requiredApprovals) {\n            pm.status = ProjectMilestoneStatus.APPROVED;\n            pm.approvedAt = block.timestamp;\n            pm.approvedBy = msg.sender;\n            pm.approvalMessage = _message;\n            \n            // Release funds\n            _releaseProjectMilestoneFunds(_milestoneId);\n        }\n\n        emit ProjectMilestoneApproved(_milestoneId, msg.sender, _message);\n    }\n\n    /**\n     * @dev Reject a project milestone\n     * @param _milestoneId Milestone ID\n     * @param _message Rejection message\n     */\n    function rejectProjectMilestone(\n        uint256 _milestoneId,\n        string memory _message\n    ) external onlyProjectMilestoneApprover(_milestoneId) validProjectMilestone(_milestoneId) {\n        require(bytes(_message).length > 0, \"Rejection message required\");\n        \n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        require(pm.status == ProjectMilestoneStatus.SUBMITTED, \"Milestone not submitted\");\n\n        pm.status = ProjectMilestoneStatus.REJECTED;\n        pm.rejectedBy = msg.sender;\n        pm.rejectedAt = block.timestamp;\n        pm.rejectionMessage = _message;\n\n        // Reset approvals\n        for (uint256 i = 0; i < pm.approvers.length; i++) {\n            pm.hasApproved[pm.approvers[i]] = false;\n        }\n\n        emit ProjectMilestoneRejected(_milestoneId, msg.sender, _message);\n    }\n\n    /**\n     * @dev Claim completion rewards for an approved milestone\n     * @param _milestoneId Milestone ID\n     */\n    function claimCompletionRewards(uint256 _milestoneId) external validProjectMilestone(_milestoneId) nonReentrant {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        require(pm.status == ProjectMilestoneStatus.APPROVED, \"Milestone not approved\");\n        \n        address recipient = pm.milestoneType == ProjectMilestoneType.OPEN ? pm.claimedBy : pm.assignedTo;\n        require(recipient == msg.sender, \"Only milestone assignee can claim rewards\");\n\n        _releaseProjectMilestoneFunds(_milestoneId);\n    }\n\n    /**\n     * @dev Internal function to release project milestone funds\n     */\n    function _releaseProjectMilestoneFunds(uint256 _milestoneId) internal {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        \n        if (pm.status != ProjectMilestoneStatus.APPROVED) {\n            return;\n        }\n\n        address recipient = pm.milestoneType == ProjectMilestoneType.OPEN ? pm.claimedBy : pm.assignedTo;\n        require(recipient != address(0), \"No recipient for milestone\");\n\n        bool fundsReleased = false;\n        for (uint256 i = 0; i < pm.supportedTokens.length; i++) {\n            address token = pm.supportedTokens[i];\n            uint256 reward = pm.rewardAmounts[token];\n            \n            if (reward > 0 && pm.escrowedAmounts[token] >= reward) {\n                fundsReleased = true;\n                \n                // Calculate platform fee\n                uint256 platformFee = (reward * projectMilestonePlatformFee) / 100;\n                uint256 recipientAmount = reward - platformFee;\n\n                // Update escrowed amounts\n                pm.escrowedAmounts[token] -= reward;\n\n                // Transfer to recipient\n                if (token == address(celoToken)) {\n                    payable(recipient).transfer(recipientAmount);\n                } else {\n                    IERC20(token).safeTransfer(recipient, recipientAmount);\n                }\n\n                // Collect platform fee\n                if (platformFee > 0) {\n                    address platformOwner = seas4Contract.owner();\n                    if (token == address(celoToken)) {\n                        payable(platformOwner).transfer(platformFee);\n                    } else {\n                        IERC20(token).safeTransfer(platformOwner, platformFee);\n                    }\n                    collectedFees[token] += platformFee;\n                    emit FeeCollected(token, platformFee, \"projectMilestoneFee\");\n                }\n\n                emit ProjectMilestoneRewardsClaimed(_milestoneId, recipient, token, recipientAmount);\n            }\n        }\n\n        // Mark as paid if funds were released\n        if (fundsReleased) {\n            pm.status = ProjectMilestoneStatus.PAID;\n            pm.paidAt = block.timestamp;\n        }\n    }\n\n    /**\n     * @dev Add a steward to a milestone\n     * @param _milestoneId Milestone ID\n     * @param _steward Steward address\n     */\n    function addMilestoneSteward(\n        uint256 _milestoneId,\n        address _steward\n    ) external validProjectMilestone(_milestoneId) validAddress(_steward) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        (, address projectOwner,,,,,,) = seas4Contract.getProject(pm.projectId);\n        require(projectOwner == msg.sender, \"Only project owner can add stewards\");\n        require(!pm.isApprover[_steward], \"Already an approver\");\n\n        pm.approvers.push(_steward);\n        pm.isApprover[_steward] = true;\n        milestoneStewards[_milestoneId].push(_steward);\n        isMilestoneSteward[_milestoneId][_steward] = true;\n\n        emit MilestoneStewardAdded(_milestoneId, _steward, msg.sender);\n    }\n\n    /**\n     * @dev Remove a steward from a milestone\n     * @param _milestoneId Milestone ID\n     * @param _steward Steward address\n     */\n    function removeMilestoneSteward(\n        uint256 _milestoneId,\n        address _steward\n    ) external validProjectMilestone(_milestoneId) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        (, address projectOwner,,,,,,) = seas4Contract.getProject(pm.projectId);\n        require(projectOwner == msg.sender, \"Only project owner can remove stewards\");\n        require(isMilestoneSteward[_milestoneId][_steward], \"Not a steward\");\n\n        pm.isApprover[_steward] = false;\n        isMilestoneSteward[_milestoneId][_steward] = false;\n\n        emit MilestoneStewardRemoved(_milestoneId, _steward, msg.sender);\n    }\n\n    /**\n     * @dev Cancel a project milestone and refund funds\n     * @param _milestoneId Milestone ID\n     */\n    function cancelProjectMilestone(uint256 _milestoneId) external validProjectMilestone(_milestoneId) nonReentrant {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        (, address projectOwner,,,,,,) = seas4Contract.getProject(pm.projectId);\n        require(projectOwner == msg.sender, \"Only project owner can cancel\");\n        require(\n            pm.status == ProjectMilestoneStatus.DRAFT || \n            pm.status == ProjectMilestoneStatus.ACTIVE ||\n            pm.status == ProjectMilestoneStatus.REJECTED,\n            \"Cannot cancel milestone in current state\"\n        );\n\n        pm.status = ProjectMilestoneStatus.CANCELLED;\n\n        // Refund all escrowed funds to project owner\n        for (uint256 i = 0; i < pm.supportedTokens.length; i++) {\n            address token = pm.supportedTokens[i];\n            uint256 refundAmount = pm.escrowedAmounts[token];\n            \n            if (refundAmount > 0) {\n                pm.escrowedAmounts[token] = 0;\n\n                if (token == address(celoToken)) {\n                    payable(projectOwner).transfer(refundAmount);\n                } else {\n                    IERC20(token).safeTransfer(projectOwner, refundAmount);\n                }\n            }\n        }\n\n        emit ProjectMilestoneCancelled(_milestoneId, msg.sender);\n    }\n\n    /**\n     * @dev Update platform fee for project milestones (only owner)\n     */\n    function setProjectMilestonePlatformFee(uint256 _fee) external onlyOwner {\n        require(_fee <= 10, \"Fee cannot exceed 10%\");\n        projectMilestonePlatformFee = _fee;\n    }\n\n    // ============ PROJECT MILESTONE VIEW FUNCTIONS ============\n\n    /**\n     * @dev Get project milestone details\n     */\n    function getProjectMilestone(uint256 _milestoneId) external view returns (\n        uint256 id,\n        uint256 projectId,\n        ProjectMilestoneType milestoneType,\n        ProjectMilestoneStatus status,\n        address assignedTo,\n        address claimedBy,\n        string memory title,\n        string memory description,\n        string memory requirements,\n        string memory evidenceHash,\n        uint256 requiredApprovals,\n        bool allowSiteAdminApproval,\n        uint256 createdAt,\n        uint256 deadline,\n        uint256 claimedAt,\n        uint256 submittedAt,\n        uint256 approvedAt,\n        uint256 paidAt,\n        address[] memory supportedTokens\n    ) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        return (\n            pm.id,\n            pm.projectId,\n            pm.milestoneType,\n            pm.status,\n            pm.assignedTo,\n            pm.claimedBy,\n            pm.title,\n            pm.description,\n            pm.requirements,\n            pm.evidenceHash,\n            pm.requiredApprovals,\n            pm.allowSiteAdminApproval,\n            pm.createdAt,\n            pm.deadline,\n            pm.claimedAt,\n            pm.submittedAt,\n            pm.approvedAt,\n            pm.paidAt,\n            pm.supportedTokens\n        );\n    }\n\n    /**\n     * @dev Get project milestone reward amount for a token\n     */\n    function getProjectMilestoneReward(uint256 _milestoneId, address _token) external view returns (uint256) {\n        return projectMilestones[_milestoneId].rewardAmounts[_token];\n    }\n\n    /**\n     * @dev Get project milestone escrowed amount for a token\n     */\n    function getProjectMilestoneEscrowed(uint256 _milestoneId, address _token) external view returns (uint256) {\n        return projectMilestones[_milestoneId].escrowedAmounts[_token];\n    }\n\n    /**\n     * @dev Get all milestone IDs for a project\n     */\n    function getProjectMilestones(uint256 _projectId) external view returns (uint256[] memory) {\n        return projectMilestoneIds[_projectId];\n    }\n\n    /**\n     * @dev Get milestone approvers\n     */\n    function getMilestoneApprovers(uint256 _milestoneId) external view returns (address[] memory) {\n        return projectMilestones[_milestoneId].approvers;\n    }\n\n    /**\n     * @dev Check if address has approved milestone\n     */\n    function hasApprovedMilestone(uint256 _milestoneId, address _approver) external view returns (bool) {\n        return projectMilestones[_milestoneId].hasApproved[_approver];\n    }\n\n    /**\n     * @dev Get approval count for milestone\n     */\n    function getMilestoneApprovalCount(uint256 _milestoneId) external view returns (uint256) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        uint256 count = 0;\n        for (uint256 i = 0; i < pm.approvers.length; i++) {\n            if (pm.hasApproved[pm.approvers[i]]) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * @dev Get milestone stewards\n     */\n    function getMilestoneStewards(uint256 _milestoneId) external view returns (address[] memory) {\n        return milestoneStewards[_milestoneId];\n    }\n\n    /**\n     * @dev Get milestones claimed by a user\n     */\n    function getUserClaimedMilestones(address _user) external view returns (uint256[] memory) {\n        return userClaimedMilestones[_user];\n    }\n\n    /**\n     * @dev Get project milestone count\n     */\n    function getProjectMilestoneCount() external view returns (uint256) {\n        return nextProjectMilestoneId;\n    }\n\n    /**\n     * @dev Check if user can submit milestone\n     */\n    function canSubmitMilestone(uint256 _milestoneId, address _user) external view returns (bool) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        \n        if (pm.milestoneType == ProjectMilestoneType.OPEN) {\n            return pm.claimedBy == _user && pm.status == ProjectMilestoneStatus.CLAIMED;\n        } else {\n            return pm.assignedTo == _user && \n                   (pm.status == ProjectMilestoneStatus.ACTIVE || pm.status == ProjectMilestoneStatus.REJECTED);\n        }\n    }\n\n    /**\n     * @dev Check if user can approve milestone\n     */\n    function canApproveMilestone(uint256 _milestoneId, address _user) external view returns (bool) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        return (pm.isApprover[_user] || (pm.allowSiteAdminApproval && seas4Contract.superAdmins(_user))) &&\n               pm.status == ProjectMilestoneStatus.SUBMITTED &&\n               !pm.hasApproved[_user];\n    }\n\n    /**\n     * @dev Check if milestone can be claimed (for open milestones)\n     */\n    function canClaimMilestone(uint256 _milestoneId) external view returns (bool) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        return pm.milestoneType == ProjectMilestoneType.OPEN &&\n               pm.status == ProjectMilestoneStatus.ACTIVE &&\n               pm.claimedBy == address(0);\n    }\n\n    /**\n     * @dev Get project milestone approval details\n     */\n    function getProjectMilestoneApproval(uint256 _milestoneId) external view returns (\n        string memory approvalMessage,\n        address approvedBy,\n        uint256 approvedAt\n    ) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        return (pm.approvalMessage, pm.approvedBy, pm.approvedAt);\n    }\n\n    /**\n     * @dev Get project milestone rejection details\n     */\n    function getProjectMilestoneRejection(uint256 _milestoneId) external view returns (\n        string memory rejectionMessage,\n        address rejectedBy,\n        uint256 rejectedAt\n    ) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        return (pm.rejectionMessage, pm.rejectedBy, pm.rejectedAt);\n    }\n\n    /**\n     * @dev Get all supported tokens for a milestone with their amounts\n     */\n    function getProjectMilestoneTokenDetails(uint256 _milestoneId) external view returns (\n        address[] memory tokens,\n        uint256[] memory rewardAmounts,\n        uint256[] memory escrowedAmounts\n    ) {\n        ProjectMilestone storage pm = projectMilestones[_milestoneId];\n        uint256 length = pm.supportedTokens.length;\n        tokens = new address[](length);\n        rewardAmounts = new uint256[](length);\n        escrowedAmounts = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            address token = pm.supportedTokens[i];\n            tokens[i] = token;\n            rewardAmounts[i] = pm.rewardAmounts[token];\n            escrowedAmounts[i] = pm.escrowedAmounts[token];\n        }\n\n        return (tokens, rewardAmounts, escrowedAmounts);\n    }\n}\n\n"
      }
    }
  }
}